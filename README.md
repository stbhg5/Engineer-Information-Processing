# Engineer-Information-Processing
정보처리기사 시험준비
<br/><br/>

- 필기시험<br/>
2022.02.14
![20220214_정보처리기사](https://user-images.githubusercontent.com/83276757/154078156-825862db-45fa-4e70-a02a-e053b3e77768.jpg)

2022.02.15
![20220215_정보처리기사](https://user-images.githubusercontent.com/83276757/154077934-87ed51b7-e51f-4c6e-9db2-6f320207202a.jpg)

2022.02.16
![20220216_정보처리기사 공부](https://user-images.githubusercontent.com/83276757/154306357-81a01ec1-5706-405b-9071-5078d6f3e28c.jpg)

2022.02.17
![20220217_정보처리기사 공부](https://user-images.githubusercontent.com/83276757/154706002-11da7f0f-b7dc-4e65-9704-b3bd34fb8402.jpg)

2022.02.18
![20220218_정보처리기사 공부](https://user-images.githubusercontent.com/83276757/154706036-88f1f87f-e864-44e6-9362-5c9ecc8f6dc0.jpg)

2022.02.19
![20220219_정보처리기사 공부](https://user-images.githubusercontent.com/83276757/154811953-19dec16d-8208-4776-9d74-3cfa858b8514.jpg)

2022.02.20
![20220220_정보처리기사 공부](https://user-images.githubusercontent.com/83276757/154845650-70e232f6-202e-4bf8-b63f-5cd2ef9f5642.jpg)

2022.02.21
![20220221_정보처리기사 공부](https://user-images.githubusercontent.com/83276757/154989822-5efbec4d-31d8-4c02-8c5f-a8642ce20ba6.jpg)

2022.02.22
![20220222_정보처리기사 공부](https://user-images.githubusercontent.com/83276757/155151978-9a7f4773-07a7-44f2-a018-282632e71566.jpg)

2022.02.23
![20220223_정보처리기사 공부](https://user-images.githubusercontent.com/83276757/155337055-f53aee53-b6d3-4297-b34c-1fc200c1dbcd.jpg)


2022.02.24
![20220224_정보처리기사 공부](https://user-images.githubusercontent.com/83276757/155568011-9f7a74b2-e8ef-46c6-afbe-b304183146e5.jpg)

2022.02.25
![20220225_정보처리기사 공부](https://user-images.githubusercontent.com/83276757/155671661-904081d1-5432-4ec1-a619-ceb7650a4cce.jpg)

2022.02.26
![20220226_정보처리기사 공부](https://user-images.githubusercontent.com/83276757/155829345-a779c135-31d3-41f7-a37c-e59f548e2b90.jpg)

2022.02.27
![20220227_정보처리기사 공부](https://user-images.githubusercontent.com/83276757/155890222-d5e7656f-2799-44f4-a44b-25835d19e97d.jpg)

2022.02.28
![20220228_정보처리기사 공부](https://user-images.githubusercontent.com/83276757/155983787-d97410bd-89e6-47f1-a34a-5f47ab94e7bd.jpg)

2022.03.01
![20220301_정보처리기사 공부](https://user-images.githubusercontent.com/83276757/156138824-48e0a9ba-7fe2-41b0-8a03-c0a36a185202.jpg)

2022.03.02
![20220302_정보처리기사 공부](https://user-images.githubusercontent.com/83276757/156408441-cd2b55fa-0de7-48d0-b22f-90d4b10c9c10.jpg)

2022.03.03
![20220303_정보처리기사 공부](https://user-images.githubusercontent.com/83276757/156584107-e503cebc-da41-40ba-9a3b-bb73e593ade6.jpg)

2022.03.04
![20220304_정보처리기사 공부](https://user-images.githubusercontent.com/83276757/156754204-f98b3b38-1a90-44f8-911d-faa02ee1a8b7.jpg)

2022.03.05
![20220305_정보처리기사 시험](https://user-images.githubusercontent.com/83276757/156871522-2ba97e60-156b-4be8-8aa1-a66725767716.jpg)
<br/><br/>

- 실기시험<br/>
2022.03.12
![20220312_정보처리기사 공부](https://user-images.githubusercontent.com/83276757/158006438-41d4769e-fa7f-41d7-a262-a661a47dd9c2.jpg)

2022.03.13
![20220313_정보처리기사 공부](https://user-images.githubusercontent.com/83276757/158050052-cb4ab66d-38f0-4173-b190-c4b83626be27.jpg)

2022.03.14
![20220314_정보처리기사 공부](https://user-images.githubusercontent.com/83276757/158186205-d62f10e1-d059-4a3a-b06a-3be9edde214c.jpg)

2022.03.15
![20220315_정보처리기사 공부](https://user-images.githubusercontent.com/83276757/158402315-8405074b-f42b-40f8-bffd-6ca1aa1db77e.jpg)

2022.03.16
![20220316_정보처리기사 공부](https://user-images.githubusercontent.com/83276757/158616475-ff09ace1-2d53-4154-8820-3b2607fcdf0e.jpg)

2022.03.17
![20220317_정보처리기사 공부](https://user-images.githubusercontent.com/83276757/158818963-33ebc0ef-ed18-4ae2-8eb2-fe38893195ab.jpg)

2022.03.18
![20220318_정보처리기사 공부](https://user-images.githubusercontent.com/83276757/159001843-301736cb-777c-4bcb-8519-3c6da31f09a6.jpg)

2022.03.19
![20220319_정보처리기사 공부](https://user-images.githubusercontent.com/83276757/159107715-22fd0424-462e-48d6-becf-74676eb58ca1.jpg)

2022.03.20
![20220320_정보처리기사 공부](https://user-images.githubusercontent.com/83276757/159153400-732f0719-774b-44e7-aee2-dfae2fb0f9ff.jpg)

2022.03.21
![20220321_정보처리기사 공부](https://user-images.githubusercontent.com/83276757/159286419-f9bc9f34-7552-4f12-8ad5-ec6e936c9342.jpg)

2022.03.22
![20220322_정보처리기사 공부](https://user-images.githubusercontent.com/83276757/159499368-c4f11c09-1437-4d80-a002-5bfa00e44584.jpg)

2022.03.24
![20220324_정보처리기사 공부](https://user-images.githubusercontent.com/83276757/159948452-70975d1f-7e07-4914-a7b7-683dee996cfc.jpg)

2022.03.25
![20220325_정보처리기사 공부](https://user-images.githubusercontent.com/83276757/160143372-7ac5357d-5904-4031-a307-e53eb05f84e0.jpg)

2022.03.26
![20220326_정보처리기사 공부](https://user-images.githubusercontent.com/83276757/160222120-cd77db88-649a-471b-80ec-b9eeec6ad1c4.jpg)

2022.03.27
![20220327_정보처리기사 공부](https://user-images.githubusercontent.com/83276757/160268481-e7cecdb2-002e-4c49-ad49-f90adaf9c00e.jpg)

2022.03.28
![20220328_정보처리기사 공부](https://user-images.githubusercontent.com/83276757/160415503-42d6a613-98b9-4b7c-916c-2af35f856525.jpg)

2022.03.29
![20220329_정보처리기사 공부](https://user-images.githubusercontent.com/83276757/160635924-ec6e8edd-0164-4c89-abb1-f9436bfe88a3.jpg)

2022.03.30
![20220330_정보처리기사 공부](https://user-images.githubusercontent.com/83276757/160857244-a3a1c0e8-bd48-423e-8800-a3787dbb8393.jpg)

2022.03.31
![20220331_정보처리기사 공부](https://user-images.githubusercontent.com/83276757/161077870-718a3fd8-fb75-42db-8eed-c2c3507fd063.jpg)

2022.04.01
![20220401_정보처리기사 공부](https://user-images.githubusercontent.com/83276757/161257864-9046b90a-f9ec-4a0d-ae9a-f299d382a0f7.jpg)

2022.04.02
![20220402_정보처리기사 공부](https://user-images.githubusercontent.com/83276757/161368777-431c355a-723a-4c4c-a0bb-959553526e72.jpg)

2022.04.03
![20220403_정보처리기사 공부](https://user-images.githubusercontent.com/83276757/161421209-277b62a8-5f1d-492a-b1b2-75a493dfebad.jpg)

2022.04.04
![20220404_정보처리기사 공부](https://user-images.githubusercontent.com/83276757/161557719-4c3b8adb-fa6a-4c49-a452-35167060ae47.jpg)

2022.04.05
![20220405_정보처리기사 공부](https://user-images.githubusercontent.com/83276757/161772250-fef0e0e6-8972-464b-8a4b-6c49c4c4e4d5.jpg)

2022.04.06
![20220406_정보처리기사 공부](https://user-images.githubusercontent.com/83276757/162015331-3d59ec59-6446-41bd-8f91-f9d088fca10e.jpg)

2022.04.07
![20220407_정보처리기사 공부](https://user-images.githubusercontent.com/83276757/162254658-d22226ba-549c-4f81-82fd-fd3e591d3130.jpg)

2022.04.08
![20220408_정보처리기사 공부](https://user-images.githubusercontent.com/83276757/162480393-7b6a1775-3f51-4423-92ac-c31542be421a.jpg)

2022.04.09
![20220409_정보처리기사 공부](https://user-images.githubusercontent.com/83276757/162573422-845ee47a-7903-4d33-947d-e330c58f8129.jpg)

2022.04.10
![20220410_정보처리기사 공부](https://user-images.githubusercontent.com/83276757/162611781-c35672bc-7674-4581-8f50-9dd73e970cff.jpg)

2022.04.11
![20220411_정보처리기사 공부](https://user-images.githubusercontent.com/83276757/162763353-86f3b097-10f2-4e9d-836e-2d193596d250.jpg)

2022.04.12
![20220412_정보처리기사 공부](https://user-images.githubusercontent.com/83276757/162989629-f937b2ce-01f4-4bc0-8322-4737689c6c29.jpg)

2022.04.13
![20220413_정보처리기사 공부](https://user-images.githubusercontent.com/83276757/163224711-1655b4a2-e58b-4593-b9d4-3a0d9bdcef75.jpg)

2022.04.14
![20220414_정보처리기사 공부](https://user-images.githubusercontent.com/83276757/163430012-7a8a5a69-a03c-4c54-8404-9a0d492dbb3b.jpg)

2022.04.15
![20220415_정보처리기사 공부](https://user-images.githubusercontent.com/83276757/163594971-4dd89f79-08fa-44e3-a6ce-f140735c5dd2.jpg)

2022.04.16
![20220416_정보처리기사 공부](https://user-images.githubusercontent.com/83276757/163663629-8a3ba1b0-1828-460a-be59-2fa60eabf177.jpg)

2022.04.17
![20220417_정보처리기사 공부](https://user-images.githubusercontent.com/83276757/163712193-466f051a-cec6-48dc-8c2d-47d5d1d1fbf7.jpg)

2022.04.18
![20220418_정보처리기사 공부](https://user-images.githubusercontent.com/83276757/163834735-c3f6143d-b4e2-4d13-af3f-97a8474d5571.jpg)

2022.04.19
![20220419_정보처리기사 공부](https://user-images.githubusercontent.com/83276757/164045185-d46ddf84-f9dd-485a-b378-1a77010499e2.jpg)

2022.04.20
![20220420_정보처리기사 공부](https://user-images.githubusercontent.com/83276757/164247247-153b1ba1-d15a-4345-87d3-27a3a629537d.jpg)

2022.04.21
![20220421_정보처리기사 공부](https://user-images.githubusercontent.com/83276757/164471751-ca217a3c-b410-4742-a8f3-af2dc2d1c1b3.jpg)

2022.04.22
![20220422_정보처리기사 공부](https://user-images.githubusercontent.com/83276757/164609891-6b78b479-fe4e-4ce5-a632-cffa59f8a5b6.jpg)

2022.04.23
![20220423_정보처리기사 공부](https://user-images.githubusercontent.com/83276757/164883761-ee96203c-5306-46a2-ae92-04c8fb85987c.jpg)

2022.04.24
![20220424_정보처리기사 공부](https://user-images.githubusercontent.com/83276757/164958795-8c3dbba4-0fc7-45b5-a57e-65c1a71da447.jpg)

2022.04.25
![20220425_정보처리기사 공부](https://user-images.githubusercontent.com/83276757/165126631-0e9e9bb5-cb71-4a16-9a79-fa2ea4398b5f.jpg)

2022.04.26
![20220426_정보처리기사 공부](https://user-images.githubusercontent.com/83276757/165331340-48c16ecb-f208-453e-9bff-13f875dedf0e.jpg)

2022.04.28
![20220428_정보처리기사 공부](https://user-images.githubusercontent.com/83276757/165785359-6af9bca7-672f-46d9-ab8e-aa65fa57d605.jpg)

2022.04.29
![20220429_정보처리기사 공부](https://user-images.githubusercontent.com/83276757/165966781-83efb760-4ed3-49d9-89db-fc6adbf20676.jpg)


[정보처리기사 실기시험 용어 총정리_송진성]


1. 요구사항 확인

1) 소프트웨어 개발 방법론

@1 소프트웨어 생명주기(SDLC; Software Development Life Cycle) 모델 개념 : 시스템의 요구
분석부터 유지보수까지 전 공정을 체계화한 절차.

@2 소프트웨어 생명주기 모델 프로세스
1 요구사항 분석 - 2 설계 - 3 구현 - 4 테스트 - 5 유지보수

@3 소프트웨어 생명주기 모델 종류 (전통적(문서화 강조) ↔ 애자일)
- 폭포수 모델 (Waterfall Model) : 소프트웨어 개발 시 각 단계를 확실히 마무리 지은 후에 다
음 단계로 넘어가는 모델. 가장 오래된 모델. 선형 순차적 모형으로 고전적 생명주기 모형이라
고도 함. 모형의 적용 경험과 성공 사례가 많음. 단계별 정의와 산출물이 명확. 요구사항 변경
어려움.
(절차 : 타당성 검토 → 계획 → 요구사항 분석 → 설계 → 구현 → 테스트 → 유지보수)
(폭포수 모델 ↔ 애자일 방법론)
- 프로토타이핑 모델 (Prototyping Model) : 고객이 요구한 주요 기능을 프로토타입으로 구현
하여, 고객의 피드백을 반영하여 소프트웨어를 만들어가는 모델. 발주자나 개발자 모두에게
공동의 참조 모델을 제공. 구현 단계의 구현 골격.
(절차 : 요구사항 분석 → 프로토타입 개발 → 프로토타입 평가(→ 요구사항 분석) → 구현 → 테스
 트)
- 나선형 모델 (Spiral Model) : 시스템 개발 시 위험을 최소화하기 위해 점진적으로 완벽한
시스템으로 개발해 나가는 모델.
(절차 : 계획 및 정의 → 위험 분석 → 개발 → 고객 평가(→ 계획 및 정의))
- 반복적 모델 (Iteration Model) : 구축대상을 나누어 병렬적으로 개발 후 통합하거나, 반복
적으로 개발하여 점증 완성시키는 SDLC 모델. 사용자의 요구사항 일부분 혹은 제품 일부분을
반복적으로 개발하여 최종 시스템으로 완성하는 모델.
(절차 : 개발대상 → 분석 → 설계 → 구현
		 → 분석 → 설계 → 구현
		 → 분석 → 설계 → 구현)

@4 소프트웨어 개발 방법론(Software Development Methodology) 개념 : 소프트웨어 개발 전
과정에 지속적으로 적용할 수 있는 방법, 절차, 기법

@5 소프트웨어 개발 방법론 종류
- 구조적 방법론 (Structured Development) : 전체 시스템을 기능에 따라 나누어 개발하고, 이를
통합하는 분할과 정복 접근 방식의 방법론. 프로세스 중심의 하향식 방법론. 구조적 프로그래밍
표현을 위해 나씨 슈나이더만(Nassi-Shneiderman) 차트 사용.
(나씨 슈나이더만 차트 특징 : 논리의 기술에 중점을 둔 도형식 표현 방법. 연속, 선택 및 다중
 선택, 반복 등의 제어 논리 구조로 표현. 조건이 복합되어 있는 곳의 처리를 시각적으로 명확
 히 식별하는데 적합)
- 정보공학 방법론 (Information Engineering Development) : 정보시스템 개발에 필요한 관리
절차와 작업 기법을 체계화한 방법론. 개발주기를 이용해 대형 프로젝트를 수행하는 체계적인
방법론.
- 객체 지향 방법론 (Object-Oriented Development) : '객체'라는 기본 단위로 시스템을 분석
및 설계하는 방법론. 복잡한 현실 세계를 사람이 이해하는 방식으로 시스템에 적용하는 방법론.
객체, 클래스, 메시지를 사용.
- 컴포넌트 기반 방법론 (CBD; Component Based Development) : 소프트웨어를 구성하는 컴포넌
트를 조립해서 하나의 새로운 응용 프로그램을 작성하는 방법론. 개발 기간 단축으로 인한 생산
성 향상. 새로운 기능 추가 쉬움(확장성). 소프트웨어 재사용이 가능.
- 애자일 방법론 (Agile Development) : 절차보다는 사람이 중심이 되어 변화에 유연하고 신속
하게 적응하면서 효율적으로 시스템을 개발할 수 있는 신속 적응적 경량 개발 방법론. 개발 과
정의 어려움을 극복하기 위해 적극적으로 모색한 방법론.
(애자일 방법론 ↔ 폭포수 모델)
- 제품 계열 방법론 (Product Line Development) : 특정 제품에 적용하고 싶은 공통된 기능을
정의하여 개발하는 방법론. 임베디드 소프트웨어를 작성하는데 유용한 방법론. 영역 공학과
응용 공학으로 구분
(영역 공학 : 영역 분석, 영역 설계, 핵심 자산을 구현하는 영역
 응용 공학 : 제품 요구분석, 제품 설계, 제품을 구현하는 영역)

@6 애자일 방법론의 유형 (애자일(코드 강조) ↔ 전통적)
- XP (eXtreme Programming) : 의사소통 개선과 즉각적 피드백으로 소프트웨어 품질을 높이기
위한 방법론. 1~3주의 반복(Iteration) 개발주기. 5가지 가치와 12개의 실천항목이 존재.
(XP의 5가지 가치 [두음 - 용단의 피존]
 용기 (Courage) : 용기를 가지고 자신감 있게 개발(코드를 작성하기 전에 테스트, 빠르게 피
 드백, 테스트에 부합하지 못하는 코드를 리팩토링할 수 있는 용기).
 단순성 (Simplicity) : 필요한 것만 하고 그 이상의 것들은 하지 않음.
 의사소통 (Communication) : 개발자, 관리자, 고객 간의 원활한 소통.
 피드백 (Feedback) : 의사소통에 대한 빠른 피드백.
 존중 (Respect) : 팀원 간의 상호 존중.)
(XP의 12가지 기본원리
 짝 프로그래밍 (Pair Programming) : 개발자 둘이서 짝으로 코딩하는 원리.
 공동 코드 소유 (Collective Ownership) : 시스템에 있는 코드는 누구든지 언제라도 수정 가능
 하다는 원리.
 지속적인 통합 (CI; Continuous Integration) : 매일 여러 번씩 소프트웨어를 통합하고 빌드
 해야 한다는 원리.
 계획 세우기 (Planning Process) : 고객이 요구하는 비즈니스 가치를 정의하고, 개발자가 필요
 한 것은 무엇이며 어떤 부분에서 지연될 수 있는지를 알려주어야 한다는 원리.
 작은 릴리즈 (Small Release) : 작은 시스템을 먼저 만들고, 짧은 단위로 업데이트한다는 원리.
 메타포어 (Metaphor) : 공통적인 이름 체계와 시스템 서술서를 통해 고객과 개발자 간의 의사
 소통을 원활하게 한다는 원리.
 간단한 디자인 (Simple Design) : 현재의 요구사항에 적합한 가장 단순한 시스템을 설계한다는
 원리.
 테스트 기반 기발 (TDD; Test Driven Develop) : 작성해야 하는 프로그램에 대한 테스트를 먼
 저 수행하고 이 테스트를 통과할 수 있도록 실제 프로그램의 코드를 작성한다는 원리.
 리팩토링 (Refactoring) : 프로그램의 기능을 바꾸지 않으면서 중복제거, 단순화 등을 위해
 시스템 재구성한다는 원리.
 40시간 작업 (40-Hour Work) : 개발자가 피곤으로 인해 실수하지 않도록 일주일에 40시간 이상
 을 일하지 말아야 한다는 원리.
 고객 상주 (On Site Customer) : 개발자들의 질문에 즉각 대답해 줄 수 있는 고객을 프로젝트
 에 풀타임으로 상주시켜야 한다는 원리.
 코드 표준 (Coding Standard) : 효과적인 공동 작업을 위해서는 모든 코드에 대한 코딩 표준을
 정의해야 한다는 원리.)
- 스크럼 (SCRUM) : 매일 정해진 시간, 장소에서 짧은 시간의 개발을 하는 팀을 위한 프로젝트
관리 중심 방법론.
(주요개념, 설명
 백로그 (Backlog) : 제품과 프로젝트에 대한 요구사항.
 스프린트 (Sprint) : 2~4주의 짧은 개발 기간으로 반복적 수행으로 개발품질 향상.
 스크럼 미팅 (Scrum Meeting) : 매일 15분 정도 미팅으로 To-Do List 계획수립. 데일리 미팅
 (Daily Meeting)이라고도 함.
 스크럼 마스터 (Scrum Master) : 프로젝트 리더, 스크럼 수행 시 문제를 인지 및 해결하는 사
 람.
 스프린트 회고 (Sprint Retrospective) : 스프린트 주기를 되돌아보며 정해놓은 규칙 준수 여
 부, 개선점 등을 확인 및 기록. 해당 스프린트가 끝난 시점이나 일정 주기로 시행.
 번 다운 차트 (Burn Down Chart) : 남아있는 백로그 대비 시간을 그래픽적으로 표현한 차트.
 백로그는 보통 수직축에 위치하며 시간은 수평축에 위치.)
- 린 (LEAN) : 도요타의 린 시스템 품질기법을 소프트웨어 개발 프로세스에 적용해서 낭비 요소
를 제거하여 품질을 향상시킨 방법론. JIT(Just In Time), 칸반(Kanban)보드 사용.
(7가지 원칙 : 낭비제거, 품질 내재화, 지식 창출, 늦은 확정, 빠른 인도, 사람 존중, 전체 최
 적화)

@7 객체 지향 분석(OOA; Object Oriented Analysis) : 사용자의 요구사항을 분석하여 요구된
문제와 관련된 모든 클래스(객체), 속성과 연산, 관계를 정의하여 모델링하는 기법.

@8 객체 지향 분석 방법론 종류
- OOSE (Object Oriented Software Engineering) / 야콥슨(Jacobson) : 유스케이스에 의한 접근
방법으로 유스케이스를 모든 모델의 근간으로 활용되는 방법론. 분석, 설계, 구현 단계로 구성.
기능적 요구사항 중심을 시스템.
- OMT (Object Modeling Technology) / 럼바우(Rumbaugh) : 그래픽 표기법을 이용하여 소프트
웨어 구성요소를 모델링하는 방법론. 분석 절차는 객체 모델링 → 동적 모델링 → 기능 모델링
순서로 진행.
([두음 - 객동기]
 객체 모델링 (Object Modeling) : 정보 모델링(Information Modeling)이라고도 함. 시스템에서
 요구하는 객체를 찾고 객체들 간의 관계를 정의하여 ER 다이어그램을 만드는 과정까지의 모델
 링. 객체 다이어그램을 활용하여 표현.
 동적 모델링 (Dynamic Modeling) : 시간의 흐름에 따라 객체들 사이의 제어 흐름, 동작 순서
 등의 동적인 행위를 표현하는 모델링. 상태 다이어그램을 활용하여 표현.
 기능 모델링 (Functional Modeling) : 프로세스들의 자료 흐름을 중심으로 처리 과정 표현하는
 모델링. 자료 흐름도(DFD)를 활용하여 표현.)
- OOD (Object Oriented Design) / 부치(Booch) : 설계 문서화를 강조하여 다이어그램 중심으로
개발하는 방법론. 분석과 설계의 분리가 불가능. 분석하는데 이용된 객체 모델의 설계 시 적용.

@9 비용산정 모형 분류
- 하향식 산정 방법 : 경험 많은 전문가에게 비용 산정을 의뢰하거나 여러 전문가와 조정자를
통해 산정하는 방식.
(종류 : 전문가 판단,
 델파이 기법(전문가의 경험적 지식을 통한 문제 해결 및 미래예측을 위한 기법으로 전문가 합
 의법이라고도 한다))
- 상향식 산정 방법 : 세부적인 요구사항과 기능에 따라 필요한 비용을 계산하는 방식.
(코드 라인 수(LoC), Man Month, COCOMO 모형, 푸트남 모형, 기능점수(FP) 모형)

@10 비용산정 모형 종류
- LoC (Lines of Code) 모형 : 소프트웨어 각 기능의 원시 코드 라인 수의 낙관치, 중간치, 비관
치를 측정하여 예측치를 구하고 이를 이용한 비용산정 방식. 측정이 쉽고 이해하기 쉬워 많이
사용한다. 예측치를 이용하여 생산성, 노력, 개발 기간 등의 비용을 산정한다.
(예측치 = (o+4m+p) / 6 (o : 낙관치, m : 중간치, p : 비관치)
 비관치 : 가장 많이 측정된 코드 라인 수
 중간치 : 측정된 모든 코드 라인 수의 평균
 낙관치 : 가장 적게 측정된 코드 라인 수)
- Man Month 모형 : 한 사람이 1개월 동안 할 수 있는 일의 양을 기준으로 한 프로젝트 비용산정
방식.
(Man Month = Loc / 프로그래머의 월간 생산성)
 프로젝트 기간 = Man Month / 프로젝트 인력)
- COCOMO (COnstructive COst MOdel) 모형 : 보헴(Bohem)이 제안한 모형으로 프로그램 규모에
따른 비용산정 방식. 비용산정 결과는 프로젝트를 완성하는데 필요한 노력(Man-Month)으로 산정.
비용 견적의 강도 분석 및 비용 견적의 유연성이 높아 소프트웨어 개발비 견적에 널리 통용.
조직에 따라 유형이 조직형(=기본형, 단순형), 반 분리형, 임베디드형으로 나뉨.
(COCOMO의 소프트웨어 개발 유형
 조직형 (Organic Mode) : 기관 내부에서 개발된 중 소규모의 소프트웨어로 일괄 자료 처리나
 과학 기술 계산용, 비즈니스 자료 처리 개발에 적용. 5만(50KDSI) 라인 이하의 소프트웨어를
 개발하는 유형.
 반 분리형 (Semi-Detached Mode) : 단순형과 임베디드형의 중간형. 트랜잭션 처리 시스템이나,
 데이터베이스 관리 시스템, 컴파일러, 인터프리터와 같은 유틸 개발에 적용. 30만(300KDSI) 라
 인 이하의 소프트웨어를 개발하는 유형.
 임베디드형 (Embedded Mode) : 초대형 규모의 트랜잭션 처리 시스템이나 운영체제, 실시간 처리
 시스템 등의 시스템 프로그램 개발에 적용. 30만(300KDSI) 라인 이상의 소프트웨어를 개발하는
 유형.)
- 푸트남 (Putnam) 모형 : 소프트웨어 개발주기의 단계별로 요구할 인력의 분포를 가정하는 방식.
푸트남이 제안한 것으로 생명주기 예측 모형이라고도 함. 시간에 따른 함수로 표현되는
Rayleigh-Norden 곡선의 노력 분포도를 기초로 함.
- 기능점수 (FP; Function Point) 모형 : 요구 기능을 증가시키는 인자별로 가중치를 부여하고,
요인별 가중치를 합산하여 총 기능의 점수를 계산하여 비용을 산정하는 방식.
(기능점수(FP) = 총 기능점수 X [0.65 + (0.1 X 총 영향도)]
경험을 바탕으로 단순, 보통, 복잡한 정도에 따라 가중치를 부여.

@11 일정관리 모델 종류
- 주 공정법 (CPM; Critical Path Method) : 여러 작업의 수행 순서가 얽혀 있는 프로젝트의 일
정을 계산하는 기법. 모든 자원 제약사항을 배제한 상태로 프로젝트의 시작과 끝을 나타내는 노
드(Node)와 노드 간을 연결을 통해 공정을 계산하기 위한 액티비티(Activity) 표기법.
(임계 경로(Critical Path; 주 공정) : 프로젝트의 시작에서 종료까지 가장 긴 시간이 걸리는 경
 로를 계산)
- PERT (Program Evaluation and Review Technique) : 일의 순서를 계획적으로 정리하기 위한
수렴 기법으로 비관치, 중간치, 낙관치의 3점 추정방식을 통해 일정을 관리하는 기법.
- 중요 연쇄 프로젝트 관리 (CCPM; Critical Chain Project Management) : 주 공정 연쇄법으로
자원제약사항을 고려하여 일정을 작성하는 기법.

2) 현행 시스템 분석

@12 현행 시스템 파악 절차
1단계 - 구성/기능/인터페이스 파악 : 시스템 구성 파악, 시스템 기능 파악, 시스템 인터페이스
현황 파악
2단계 - 아키텍처 및 소프트웨어 구성 파악 : 아키텍처 파악, 소프트웨어 구성 파악
3단계 - 하드웨어 및 네트워크 구성 파악 : 시스템 하드웨어 현황 파악, 네트워크 구성 파악

@13 소프트웨어 아키텍처 4+1 뷰
- 유스케이스 뷰 (Usecase View) : 유스케이스 또는 아키텍처를 도출하고 설계하며 다른 뷰를
검증하는 데 사용되는 뷰. 사용자, 설계자, 개발자, 테스트 관점
- 논리 뷰 (Logical View) : 시스템의 기능적인 요구사항이 어떻게 제공되는지 설명해주는 뷰.
설계자, 개발자 관점.
- 프로세스 뷰 (Process View) : 시스템의 비기능적인 속성으로서 자원의 효율적인 사용, 병행
실행, 비동기, 이벤트 처리 등을 표현한 뷰. 개발자, 시스템 통합자 관점.
- 구현 뷰 (Implementation View) : 개발 환경 안에서 정적인 소프트웨어 모듈의 구성을 보여주
는 뷰. 컴포넌트 구조와 의존성을 보여주고 컴포넌트에 관한 부가적인 정보 정의.
- 배포 뷰 (Deployment View) : 컴포넌트가 물리적인 아키텍처에 어떻게 배치되는가를 매핑해서
보여주는 뷰.

@14 소프트웨어 아키텍처 패턴 유형
- 계층화 패턴 (Layered Pattern) : 시스템을 계층(Layer)으로 구분하여 구성하는 패턴. 각 하위
모듈들은 특정한 수준의 추상화를 제공하고, 각 계층은 다음 상위 계층에 서비스를 제공. 서로
마주보는 두 개의 계층 사이에서만 상호작용이 이루어짐.
- 클라이언트-서버 패턴 (Client-Server Pattern) : 하나의 서버와 다수의 클라이언트로 구성된
패턴. 사용자가 클라이언트를 통해서 서버에 서비스를 요청하면 서버는 클라이언트에게 서비스를
제공. 서버는 계속 클라이언트로부터 요청을 대기.
- 파이프-필터 패턴 (Pipe-Filter Pattern) : 데이터 스트림을 생성하고 처리하는 시스템에서
사용 가능한 패턴. 서브 시스템이 입력 데이터를 받아 처리하고, 결과를 다음 서브 시스템으로
넘겨주는 과정을 반복. 필터 컴포넌트는 재사용성이 좋고, 추가가 쉽기 때문에 확장이 용이.
- 브로커 패턴 (Broker Pattern) : 분리된 컴포넌트들로 이루어진 분산 시스템에서 사용되고,
이 컴포넌트들은 원격 서비스 실행을 통해 상호작용이 가능한 패턴. 브로커 컴포넌트는 컴포넌
트 간의 통신을 조정하는 역할 수행. 서버는 자신의 기능들(서비스 및 특성)을 브로커에 넘겨주
며(Publish), 클라이언트가 브로커에 서비스를 요청하면 브로커는 클라이언트를 자신의 레지스
트리에 있는 적합한 서비스로 리다이렉션(Redirection) 함.
- 모델-뷰-컨트롤러 패턴 (MVC; Model View Controller Pattern) : MVC 패턴이라고도 하는 이 패
턴은 대화형 애플리케이션을 모델, 뷰, 컨트롤러 3개의 서브 시스템으로 구조화하는 패턴.
(모델 (Model) : 핵심 기능과 데이터 보관
 뷰 (View) : 사용자에게 정보 표시(하나 이상의 뷰가 정의될 수 있음)
 컨트롤러 (Controller) : 사용자로부터 요청을 입력받아 처리)
각 부분이 별도의 컴포넌트로 분리되어 있어서 서로 영향을 받지 않고 개발 작업 수행 가능.
컴포넌트를 분리하며 코드의 효율적인 재사용을 가능하게 하고, 여러 개의 뷰가 있어야 하는 대
화형 애플리케이션 구축에 적합.

@15 소프트웨어 아키텍처 비용 평가 모델 종류
- SAAM (Software Architecture Analysis Method) : 변경 용이성과 기능성에 집중, 평가가 용이
하여 경험이 없는 조직에서도 활용 가능한 비용 평가 모델.
- ATAM (Architecture Trade-off Analysis Method) : 아키텍처 품질 속성을 만족시키는지 판단
및 품질 속성들의 이해 상충관계까지 평가하는 모델.
- CBAM (Cost Benefit Analysis Method) : ATAM 바탕의 시스템 아키텍처 분석 중심으로 경제적
의사결정에 대한 요구를 충족하는 비용 평가 모델.
- ADR (Active Design Review) : 소프트웨어 아키텍처 구성요소 간 응집도를 평가하는 모델.
- ARID (Active Reviews for intermediate Designs) : 전체 아키텍처가 아닌 특정 부분에 대한
품질요서에 집중하는 비용 평가 모델.

@16 디자인 패턴 유형
- 목적 : 생성, 구조, 행위 [두음 - 생구행]
생성 : 객체 인스턴스 생성에 관여, 클래스 정의와 객체 생성 방식을 구조화, 캡슐화를 수행하는
패턴.
구조 : 더 큰 구조 형성 목적으로 클래스나 객체의 조합을 다루는 패턴.
행위 : 클래스나 객체들이 상호 작용하는 방법과 역할 분담을 다루는 패턴.
- 범위 : 클래스, 객체
클래스 : 클래스 간 관련성(상속 관계를 다루는 패턴). 컴파일 타임에 정적으로 결정.
객체 : 객체 간 관련성을 다루는 패턴, 런타임에 동적으로 결정.

@17 디자인 패턴 종류
[두음 - 생 빌프로팩앱싱]
- 생성 패턴 : Builder, Prototype, Factory Method, Abstract Factory, Singleton
[두음 - 구 브데파플 프록컴어]
- 구조 패턴 : Bridge, Decorator, Facade, Flyweight, Proxy, Composite, Adapter
[두음 - 행 미인이 템옵 스테비커 스트메체]
- 행위 패턴 : Mediator, Interpreter, Iterator, Template Method, Observer, State, Visitor,
Command, Strategy, Memento, Chain of Responsibility

3) 요구사항 확인

@18 요구사항의 분류
- 기능적 요구사항
개념 : 시스템이 제공하는 기능, 서비스에 대한 요구사항
도출 방법 : 특정 입력에 대해 시스템이 어떻게 반응해야 하는지에 대한 기술. 특정 상황에 대해
시스템이 어떻게 동작해야 하는지에 대한 기술.
특성 : 기능성, 완전성, 일관성
사례 : 온라인 홈페이지에서 쇼핑카트에 주문하고자 하는 품목을 저장할 수 있는 장바구니 기능
을 제공해야 함. 상품의 결제 수단은 신용카드, 무통장 입금, 포인트 결제가 가능해야 함.
- 비기능적 요구사항
개념 : 시스템이 수행하는 기능 이외의 사항, 시스템 구축에 대한 제약사항에 관한 요구사항.
도출 방법 : 품질 속성에 관련하여 시스템이 갖춰야할 사항에 관한 기술. 시스템이 준수해야 할
제한 조건에 관한 기술.
특성 : 신뢰성, 사용성, 효율성, 유지보수성, 이식성, 보안성 및 품질 관련 요구사항, 제약사항.
사례 : 특정 함수 호출시간은 3초를 넘지 않아야 함. 시스템은 하루 24시간 가동되어야 하며 가
동률 99.5%를 만족해야 함. 시스템은 운영되는 중에 패치 및 업그레이드를 할 수 있어야 함.

4) 분석 모델 확인하기


3. 데이터 입출력 구현

1) 논리 데이터 저장소 확인

@ 데이터 모델 절차
[두음 - 요개논물]
- 요구사항 분석 / - : 도출된 요구사항 간 상충을 해결하고 범위를 파악하여 외부 환경과의 상
호작용을 분석을 통해 데이터에 대한 요구 분석.
- 개념적 설계 / 개념적 데이터 모델 : 사용자의 요구에 대한 트랜잭션을 모델링 하는 단계.
현실 세계에 대한 인식을 추상적, 개념적으로 표현하여 개념적 구조를 도출하는 데이터 모델.
(트랜잭션 모델링, View 통합방법 및 Attribute 합성 고려. DB 종류와 관계 없음. 주요 산출물은
 개체관계 다이어그램이 있음)
- 논리적 설계 / 논리적 데이터 모델 : 트랜잭션의 인터페이스를 설계하는 단계. DBMS에 맞는
논리적 스키마를 설계하는 단계. 논리적 데이터 모델은 업무의 모습을 모델링 표기법으로 형상
화하여 사람이 이해하기 쉽게 표현한 데이터 모델.
(논리적 설계 단계에서 정규화를 수행. 논리적 데이터베이스 구조로 매핑(Mapping). 스키마의
 평가 및 정제. 논리적 데이터 모델을 통해 "관계 데이터 모델", 계층 데이터 모델", "네트워크
 데이터 모델", "객체 지향 데이터 모델", "객체-관계 데이터 모델" 중 하나의 모델에 맞게 설계.
 관계형 데이터베이스에서는 테이블을 설계하는 단계)
- 물리적 설계 / 물리적 데이터 모델 : 논리 데이터 모델을 특정 DBMS의 특성 및 성능을 고려하
여 물리적인 스키마를 만드는 단계. 논리 데이터 모델을 사용하고자 하는 각 DBMS의 특성을 고려
하여 데이터베이스 저장 구조(물리 데이터 모델)로 변환하는 모델.
(테이블(Table), 인덱스(Index), 뷰(View), 파티션(Partition) 등 객체를 생성. 응답시간, 저장
 공간의 효율화, 트랜잭션 처리를 고려하여 설계. 성능 측면에서 반 정규화를 수행. 레코드 집중
 의 분석 및 설계. 저장 레코드 양식 설계. 접근 경로(Access Path) 설계.)

@ 반 정규화
- 반 정규화 개념 : 정규화된 엔터티, 속성, 관계에 대해 성능 향상과 개발 운영의 단순화를 위
해 중복, 통합, 분리 등을 수행하는 데이터 모델링의 기법. 비정규화, 역정규화라고도 불린다.

@ 반 정규화 기법 : 테이블, 컬럼, 관계
- 테이블 병합 : 1:1 관계, 1:M 관계를 통합하여 조인 횟수를 줄여 성능 향상. 슈퍼타입/서브타
입 테이블 통합 통해 성능 향상.
- 테이블 분할 : 테이블을 수직 또는 수평으로 분할하는 것으로 파티셔닝이라고 함.
(수평분할 : 테이블 분할에 레코드를 기준으로 활용
 수직분할 : 하나의 테이블이 가지는 컬럼의 개수가 증가하는 경우 활용. 갱신 위주의 속성 분할,
 크기가 큰 속성 분할. 보안을 적용해야 하는 속성 분할.
- 중복 테이블 추가 : 대량의 데이터들에 대한 집계합수(GROUP BY, SUM 등)를 사용하여 실시간
통계 정보를 계산하는 경우에 효과적인 수행을 위해 별도의 통계 테이블을 두거나 중복 테이블을
추가.
(집계 테이블 추가 : 집계 데이터를 위한 테이블을 생성하고, 각 원본 테이블에 트리거를 설정하
 여 사용하는 것으로, 트리거의 오버헤드에 유의 필요.
 진행 테이블 추가 : 이력 관리 등의 목적으로 추가하는 테이블로, 적절한 데이터양의 유지와
 활용도를 높이기 위해 기본키를 적절히 설정
 특정 부분만을 포함하는 테이블 추가 : 데이터가 많은 테이블의 특정 부분만을 사용하는 경우
 해당 부분만으로 새로운 테이블을 생성)
- 컬럼 중복화 : 조인 성능 향상을 위한 중복 허용.
- 중복관계 추가 : 데이터를 처리하기 위한 여러 경로를 거쳐 조인이 가능하지만, 이때 발생할
수 있는 성능 저하를 예방하기 위해 추가적인 관계를 맺는 방법.

2) 물리 데이터 저장소 설계
3) 데이터베이스 기초 활용하기


4. 통합 구현
1) 연계 데이터 구성
2) 연계 메커니즘 구성
3) 내외부 연계 모듈 구현

@ 웹 서비스 유형
- SOAP (Simple Object Access Protocol) : HTTP, HTTPS, SMTP 등을 사용하여 XML 기반의 메시지
를 네트워크 상태에서 교환하는 프로토콜. HTTP 프로토콜 상에 SOAP Envelope, 헤더(Header),
바디(Body) 등이 추가된 XML 문서로 기본적인 송수신은 HTTP로 수행. 보통의 경우 원격 프로시저
호출(RPC; Remote Procedure Call)을 하는 메시지 패턴을 사용한다. 네트워크 노드(클라이언트)
에서 다른 쪽 노드(서버)로 메시지를 요청하고, 서버는 메시지를 즉시 응답하게 된다.
- WSDL(Web Service Description Language) : 웹 서비스명, 제공 위치, 메시지 포맷, 프로토콜
정보 등 웹 서비스에 대한 상세 정보가 기술된 XML 형식으로 구성되어 있는 언어. SOAP와 XML
스키마와 결합하여 인터넷상에 웹 서비스를 제공하기 위해 사용되기도 한다.
- UDDI(Universal Description, Discovery and Integration) : 웹 서비스에 대한 정보인 WSDL을
등록하고 검색하기 위한 저장소로 공개적으로 접근, 검색이 가능한 레지스트리이자 표준이다.
서비스 제공자는 UDDI라는 서비스 소비자에게 이미 알려진 온라인 저장소에 그들이 제공하는 서
비스 목록들을 저장하게 되고, 서비스 소비자들은 그 저장소에 접근함으로써 원하는 서비스들의
목록을 찾을 수 있게 된다. 알려진 송수신 시스템의 통합 구현에서는 서비스의 공개 및 검색과
정이 필요 없으므로, UDDI를 구축하지 않는다.


10. 애플리케이션 테스트 관리

1) 애플리케이션 테스트 케이스 설계

@ 블랙박스 테스트(Black-Box Test) : 프로그램 외부 사용자의 요구사항 명세를 보면서 수행하는
테스트(기능 테스트).
- 동등 분할 테스트 = 동치 분할 테스트, 균등 분할 테스트, 통치 클래스 분해 테스트 (Equivalence
Partitioning Testing) : 입력 데이터의 영역을 유사한 도메인별로 유효값/무효값을 그룹핑하여
대푯값 테스트 케이스를 도출하여 테스트하는 기법.
- 경곗값 분석 테스트 = 한곗값 테스트 (Boundary Value Analysis Testing) : 등가 분할 후 경곗
값 부분에서 오류 발생 확률이 높기 때문에 경곗값을 포함하여 테스트 케이스를 설계하여 테스트
하는 기법. 최솟값 바로 위, 최대치 바로 아래 등 입력값의 극한 한계를 테스트하는 기법.
- 결정 테이블 테스트 (Decision Table Testing) : 요구사항의 논리와 발생조건을 테이블 형태로
나열하여, 조건과 행위를 모두 조합하여 테스트하는 기법.
- 상태 전이 테스트 (State Transition Testing) : 테스트 대상 · 시스템이나 객체의 상태를 구
분하고, 이벤트에 의해 어느 한 상태에서 다른 상태로 전이되는 경우의 수를 수행하는 테스트
기법.
- 유스케이스 테스트 (Use Case Testing) : 시스템이 실제 사용되는 유스케이스로 모델링 되어
있을 때 프로세스 흐름을 기반으로 테스트케이스를 명세화하여 수행하는 테스트 기법.
- 분류 트리 테스트 (Classification Tree Method Testing) : SW의 일부 또는 전체를 트리 구조
로 분석 및 표현하여 테스트 케이스를 설계하여 테스트하는 기법.
- 페어와이즈 테스트 (Pairwise Testing) : 테스트 데이터값들 간에 최소한 한 번씩을 조합하는
방식이며, 이는 커버해야 할 기능적 범위를 모든 조합에 비해 상대적으로 적은 양의 테스트 세트
를 구성하기 위한 테스트 기법.
- 원인-결과 그래프 테스트 (Cause-Effect Graph Testing) : 그래프를 활용하여 입력 데이터 간
의 관계 및 출력에 미치는 영향을 분석하여 효용성이 높은 테스트 케이스를 선정하여 테스트하는
기법.
- 비교 테스트 (Comparison Testing) : 여러 버전의 프로그램에 같은 입력값을 넣어서 동일한
결과 데이터가 나오는지 비교해 보는 테스트 기법.

2) 애플리케이션 통합 테스트

3) 애플리케이션 성능 개선


11. 응용 SW 기초 기술 활용

1) 운영체제의 특징

2) 네트워크 기초 활용하기

@ 네트워크 계층(3계층) 프로토콜
- IP (Internet Protocol) : 송수신 간의 패킷 단위로 데이터를 교환하는 네트워크에서 정보를
주고받는데 사용하는 통신 프로토콜.
- ARP (Address Resolution Protocol) : IP 네트워크 상에서 IP 주소를 MAC 주소(물리 주소)로
변환하는 프로토콜.
- RARP (Reverse Address Resolution Protocol) : IP 호스트가 자신의 물리 네트워크 주소(MAC)
는 알지만 IP 주소는 모르는 경우, 서버로부터 IP 주소를 요청하기 위해 사용하는 프로토콜.
물리 네트워크(MAC) 주소에 해당하는 IP 주소를 알려주는 역순 주소 결정 프로토콜.
- ICMP (Internet Control Message Protocol) : IP 패킷을 처리할 때 발생되는 문제를 알려주는
프로토콜로 메시지 형식은 8바이트의 헤더와 가변 길이의 데이터 영역으로 분리. 수신지 도달 
불가 메시지는 수신지 또는 서비스에 도달할 수 없는 호스트를 통지하는 데 사용. ICMP 프로토콜
을 사용해서 ping 유틸리티의 구현을 통해 오류가 발생했음을 알리는 기능을 수행.
- IGMP (Internet Group Management Protocol) : 인터넷 그룹 관리 프로토콜은 호스트 컴퓨터와
인접 라우터가 멀티캐스트 그룹 멤버십을 구성하는데 사용하는 통신 프로토콜. 화상회의, IPTV
에서 활용되는 프로토콜. IGMP 기능에는 그룹 가입, 멤버십 감시, 멤버십 응답, 멤버십 탈퇴가
있음.
- 라우팅 프로토콜 (Routing Protocol) : 데이터 전송을 위해 목적지까지 갈 수 있는 여러 경로
중 최적의 경로를 설정해주는 라우터 간의 상호 통신 프로토콜.


3) 기본 개발환경 구축하기
